{
  parserClass="com.github.bjansen.intellij.pebble.PebbleParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Pebble"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.bjansen.intellij.pebble.psi"
  psiImplPackage="com.github.bjansen.intellij.pebble.psi.impl"

  elementTypeHolderClass="com.github.bjansen.intellij.pebble.psi.PebbleTypes"
  elementTypeClass="com.github.bjansen.intellij.pebble.psi.PebbleElementType"
  tokenTypeClass="com.github.bjansen.intellij.pebble.psi.PebbleTokenType"

  //psiImplUtilClass="com.github.bjansen.intellij.pebble.psi.impl.PebblePsiImplUtil"

  extends(".*_expression")=expression
  implements(".*_tag")="com.github.bjansen.intellij.pebble.psi.PebbleTag"

  tokens = [
    TAG_OPEN='{%'
    TAG_CLOSE='%}'
    VAR_OPEN='{{'
    VAR_CLOSE='}}'

    TRUE='true'
    FALSE='false'

    IS='is'

    LPAREN='('
    RPAREN=')'
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    COMMA=','

    OP_PIPE='|'
    OP_EQ='=='
    OP_ASSIGN='='

    space='regexp:\s+'

    ID_NAME='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    STRING='regexp:\"[^\"]*\"?'
    SINGLE_QUOTED_STRING="regexp:'[^']*'?"
    COMMENT='regexp:\{#((?!#})[\s\S])*(#})?'
    CONTENT='regexp:\s*hello\s*'
    NUMERIC='regexp:[0-9]+(\.[0-9]+)?'
  ]
}

pebbleFile ::= item_*

private item_ ::= (print_directive|comment_directive|tag_directive|CRLF|CONTENT)

boolean_literal ::= TRUE | FALSE
string_literal ::= STRING | SINGLE_QUOTED_STRING
numeric_literal ::= NUMERIC
identifier ::= ID_NAME

/*
 *   Print directives
 */
print_directive ::= VAR_OPEN expression filters VAR_CLOSE

filters ::= (OP_PIPE function_call_expression)*

/*
 *   Comments
 */
comment_directive ::= COMMENT

/*
 *   Tags
 */
tag_directive ::=  autoescape_tag
    | block_tag
    | cache_tag
    | extends_tag
    | filter_tag
    | flush_tag
    | for_tag
    | if_tag
    | import_tag
    | include_tag
    | macro_tag
    | parallel_tag
    | set_tag
    // TODO verbatim
//    | custom_tag TODO

autoescape_tag ::=
    TAG_OPEN "autoescape" (boolean_literal|string_literal) TAG_CLOSE
    item_*
    endautoescape_tag

endautoescape_tag ::= TAG_OPEN "endautoescape" TAG_CLOSE

block_tag ::=
    TAG_OPEN "block" (identifier|string_literal) TAG_CLOSE
    item_*
    endblock_tag

endblock_tag ::= TAG_OPEN "endblock" (identifier|string_literal)? TAG_CLOSE

cache_tag ::=
    TAG_OPEN "cache" expression TAG_CLOSE
    item_*
    endcache_tag

endcache_tag ::= TAG_OPEN "endcache" TAG_CLOSE

extends_tag ::=
    TAG_OPEN "extends" expression TAG_CLOSE

filter_tag ::=
    // TODO filter_invocation_expression instead of expression
    TAG_OPEN "filter" expression ('|' expression)* TAG_CLOSE
    item_*
    endfilter_tag

endfilter_tag ::= TAG_OPEN "endfilter" TAG_CLOSE

flush_tag ::=
    TAG_OPEN "flush" TAG_CLOSE

for_tag ::=
    TAG_OPEN "for" identifier "in" expression TAG_CLOSE
    item_*
    else_tag?
    endfor_tag

endfor_tag ::= TAG_OPEN "endfor" TAG_CLOSE

else_tag ::= TAG_OPEN "else" TAG_CLOSE item_*

if_tag ::=
    TAG_OPEN "if" expression TAG_CLOSE
    item_*
    elseif_tag*
    else_tag?
    endif_tag

endif_tag ::= TAG_OPEN "endif" TAG_CLOSE

elseif_tag ::= TAG_OPEN "elseif" expression TAG_CLOSE item_*

import_tag ::=
    TAG_OPEN "import" expression TAG_CLOSE

include_tag ::=
    TAG_OPEN "include" expression ("with" expression)? TAG_CLOSE

macro_tag ::=
    TAG_OPEN "macro" identifier function_parameters TAG_CLOSE
    item_*
    endmacro_tag

endmacro_tag ::= TAG_OPEN "endmacro" TAG_CLOSE

parallel_tag ::=
    TAG_OPEN "parallel" TAG_CLOSE
    item_*
    endparallel_tag

endparallel_tag ::= TAG_OPEN "endparallel" TAG_CLOSE

set_tag ::=
    TAG_OPEN "set" identifier OP_ASSIGN expression TAG_CLOSE

// TODO conflicts with "endXXX" when using `item_*`
// use regexp \b(?!(?:endblock|endfor)\b)[a-zA-Z_][a-zA-Z0-9_]*
custom_tag ::= TAG_OPEN "custom" expression? TAG_CLOSE


/*
 *  Expressions
 */
expression ::=
    assignment_expression
  | prefix_expression
  | parenthesized_expression
  | array_expression
  | map_expression
  | or_expression
  | and_expression
  | test_expression
  | comparison_expression
  | ternary_expression
  | additive_expression
  | multiplicative_expression
  | pipe_expression
  | concat_expression
  | range_expression
  | member_expression

prefix_expression ::= unary_op expression
assignment_expression ::= expression OP_ASSIGN expression { rightAssociative=true }
or_expression ::= expression OR expression
and_expression ::= expression AND expression
test_expression ::= expression ((IS test)|(CONTAINS expression))
comparison_expression ::= expression comparison_op expression
ternary_expression ::= expression '?' expression ':' expression
multiplicative_expression ::= expression multiplicative_op expression
pipe_expression ::= expression '|' expression
concat_expression ::= expression '~' expression
range_expression ::= expression '..' expression
additive_expression ::= expression additive_op expression
parenthesized_expression ::= LPAREN expression RPAREN
array_expression ::= '[' (expression (',' expression)*)? ']'
map_expression ::= '{' (map_element (',' map_element)*)? '}'
map_element ::= string_literal ':' expression

member_expression ::=
    function_call_expression
  | qualified_expression
  | term
qualified_expression ::= identifier ('.' (identifier !'(' | function_call_expression))+
function_call_expression ::= identifier function_parameters
function_parameters ::= LPAREN (expression (COMMA expression)*)? RPAREN

term ::= boolean_literal | NULL | NONE | string_literal | numeric_literal | identifier
test ::= NOT? (NULL | identifier)

private unary_op ::= OP_PLUS | OP_MINUS | NOT
private multiplicative_op ::= OP_DIV | OP_MULT | OP_MOD
private additive_op ::= OP_PLUS | OP_MINUS
private comparison_op ::= OP_EQ | EQUALS | OP_NEQ | OP_LE | OP_LT | OP_GE | OP_GT
